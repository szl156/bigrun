# 事件循环

## 浏览器的进程模型

### 进程

**程序运行的内存空间称为进程**

每个应用至少有一个进程，进程之间相互隔离，即使要通信也需要双方同意

### 线程

一个进程至少有一个线程，进程启动时会自动创建一个线程运行代码，称为主线程

如果程序需要同时执行多块代码，主线程就会启动更多的线程协助执行代码，所以一个进程可以包含多个线程

### 浏览器的进程与线程

**浏览器是一个多进程多线程的应用程序**

主要的进程有：

1. 浏览器进程

   主要负责界面显示、用户交互、子进程管理等。

2. 网络进程

   负责加载网络资源

3. **渲染进程**

   渲染进程启动之后，会开启一个**渲染主线程**，主线程负责执行HTML、CSS、JS代码

   默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响

## 渲染主线程

渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：

- 解析HTML，CSS
- 计算样式
- 布局
- 处理图层
- 执行全局JS代码
- ......

### 事件循环的过程

1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在。如果有，就去取第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态
3. 其他所有线程（包括其他进程的线程 ）可以随时向消息队列添加任务，新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。

### 异步

代码执行过程中会遇到一些无法立即执行的任务，比如：

- 计时完成后需要执行的任务 -- `setTimeout`、`setInterval`
- 网络通信完成后需要执行的任务 -- `XHR`、`Fetch`
- 用户操作后需要执行的任务 -- `addEventListener`

如果让渲染主线程等待这些任务完成，就会导致主线程长时间处于”阻塞状态“，从而导致浏览器卡死

> 如何理解浏览器的异步？
>
> <u>JS是单线程的，因为JS运行在渲染主线程中，而渲染主线程只有一个</u>，当某些任务发生时，比如计时器、网络、事件监听，<u>主线程将任务交给其他线程去处理</u>，自身立即结束任务的执行，转而执行后续代码。<u>当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队</u>，等待主线程调度执行。

## 任务优先级

任务没有优先级，在消息队列中先进先出；但**消息队列**有优先级

- 每个任务都有一个任务类型，同类型任务必须在同一个队列中，不同类型的任务可以分属不同的队列。再一次事件循环中，浏览器可以从不同的队列中取出任务执行
- 在浏览器中有一个微队列，微队列中的任务优先其他所有任务执行

目前Chrome的实现中，主要有以下几个队列：

- 微队列：存放需要最快执行的任务，优先级**最高**

- 交互队列：存放用户操作后产生的事件处理任务，优先级**高**

- 延时队列：存放计时器到达后的回调任务，优先级**中**

添加微任务的主要方式有 Promis、MutationObserver

> **JS的事件循环**
>
> 事件循环又称消息循环,是浏览器渲染主线程的工作方式。
>
> 在Chrome的源码中，它将开启一个不会结束的for循环，每次循环都从消息队列中取出第一个任务执行，而其它线程只需要再合适的时候将任务加入到队伍末尾即可。
>
> 根据W3C的解释，每个任务都有一个任务类型，同类型任务必须在同一个队列中，不同类型的任务可以分属不同的队列。再一次事件循环中，浏览器可以从不同的队列中取出任务执行，其中必须有一个微队列，微队列中的任务优先其他所有任务执行

> **JS的定时器可以精确计时？**
>
> 不行，原因如下：
>
> 1. 计算机硬件没有原子钟，无法做到精确计时
> 2. 操作系统的计时函数本身就有少量偏差，由于JS的计时器最终调用的时操作系统的函数，所以也会携带其偏差
> 3. 按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，就会有4ms的误差
> 4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差